### 一、 为什么引入链表

尽管`动态数组`已经解决了传统数组只能一次性分配内存空间不能改动的问题。但是仍然存在以下几个问题：

- `需要程重新分配内存`：尽管动态数组可以改变数组的大小，但是内部实际上还是重新分配一块更大的内存空间，并且在动态数组重新分配的过程中需要复制原有的数据。因此当数据量庞大的时候，动态数组或者数组需要大量的时间进行数据的复制。
- `连续的内存空间`：数组以及动态数组需要一片连续的内存空间。
- `插入和删除不方便`：动态数组在进行数据的插入和删除操作时，需要移动很多个数据。在需要多次插入删除操作时不方便。

因此需要引入一个数据结构来解决这些问题，链表在解决这些问题的同时也带来了一些缺点，即链表查找数据段时候需要遍历整个链表才能访问到要访问的数据。

### 二、 链表解决的问题

#### 灵活的空间分配

链表通过动态分配内存，解决了灵活的空间分配问题。与数组不同，数组在创建时需要预先分配一定大小的内存空间，而链表可以根据需要在运行时动态分配内存。

链表的节点不必在内存中占据连续的位置，每个节点包含数据和指向下一个节点的指针。

这使得链表能够根据需要动态添加或删除节点，而无需提前知道链表的大小或预留额外的空间。

#### O(1)的删除、新增


链表解决了动态数组等连续存储空间在删除和插入语节点时需要修改大量数据位置的问题：

##### O(1)删除：

1. **删除头节点：**

   如果要删除链表的头节点，只需将头指针移动到下一个节点，然后释放原来的头节点的内存。这个过程的时间复杂度是O(1)。

2. **删除中间节点：**

   删除中间节点需要首先遍历到要删除的节点的前一个节点，然后将这个节点删除，这个删除操作的平均时间复杂度是O(n/2)，其遍历的过程与数组移动数据的过程时间复杂度大致相同。

3. **删除尾节点：**

   对于具有尾指针的链表，其删除尾结点的时间复杂度是O(n)，因为需要遍历到尾结点的前一个指针，这个过程是O(n)，而数组的这个操作只需要O(1)。

   为了解决在某些情况下链表的访问删除新增操作不如数组快的情况，可以使用、循环链表，双向链表，循环双链表等结构解决。

##### O(1)新增：

1. **在头部插入节点：**

   若要在链表的头部插入一个节点，只需创建新节点，将新节点的指针指向当前头节点，然后将链表的头指针更新为新节点。这是O(1)的操作。

2. **在中间插入节点：**

   对于链表，如果已知要插入的位置，只需修改前一个节点的指针，使其指向新节点，新节点的指针指向原来位置的节点，这是操作的时间复杂度是O(1)，而找到这个位置的平均时间复杂度是O(n/2)。

3. **在尾部插入节点**

   在双向链表的尾部插入节点是O(1)的操作，因为我们可以直接操作尾节点的指针，将其指向新节点，并更新新节点的指针。

