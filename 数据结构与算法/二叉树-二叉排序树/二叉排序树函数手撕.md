## 一、数据结构

```c
typedef struct BinarySearchNode
{
    ELEMENTTYPE data;
    struct BinarySearchNode *left;
    struct BinarySearchNode *right;
    struct BinarySearchNode *parent;
} BinarySearchNode;

typedef struct BinarySearchTree
{
    // 根节点
    BinarySearchNode *root;
    // 树的元素个数
    int size;
    // 树的高度
    int height;
    // 自定义比较器
    int (*comparaFunc)(ELEMENTTYPE arg1, ELEMENTTYPE arg2);
    // 自定义打印器
    int (*printFunc)(ELEMENTTYPE arg);
} BinarySearchTree;
```

## 二、二叉排序树函数实现

### 初始化

```c
/* 二叉排序树初始化
 * @param **pTree 要初始化的树
 * @param *compareFunc 需要传入的比较器
 * @param *printFunc 需要传入的打印器
 * @return 非零表示插入失败
 */
int binarySearchTreeInit(BinarySearchTree **pTree, int (*compareFunc)(ELEMENTTYPE, ELEMENTTYPE), int (*printFunc)(ELEMENTTYPE));
```

- 判空。
- 初始化一个二叉排序树。
- 设置二叉排序树的高度为`0`。
- 设置二叉排序树的元素个数为`0`。
- 将二叉排序树的根节点设置为`NULL`。
- 设置二叉排序树的比较器。
- 设置二叉排序树的打印器。

### 插入

```c
/* 二叉排序树初始化
 * @param *pTree 要插入元素的树
 * @param data 需要插入的数据
 * @return 非零表示插入失败
 */
int binarySearchTreeInsert(BinarySearchTree *pTree, ELEMENTTYPE data);
```

- 判空。
- 创建一个`travelNode`结点，使其等于`根结点`。
- 初始化一个`parentNode`结点，总是令其等于`travelNode`的`父母结点`。
- 初始化一个`newNode`结点，数据为传入的`data`，作为插入结点。
- 判断当前需要插入的是否为根结点，如果是，直接将`newNode`设置为根结点。
- 如果不是，用`travelNode`遍历二叉排序树直到找到当前节点应该插入的位置。
- 此时，`parentNode`为当前`travelNode`的父母结点。
- 比较器返回的结果确定要插入的是左子树还是右子树。
- 插入节点。

### 判断节点类型

```c
// 节点的度为2
static int binarySearchTreeHasTwoChildrens(BinarySearchNode *node);

// 节点的度为1
static int binarySearchTreeHasOneChild(BinarySearchNode *node);

// 叶子节点
static int binarySearchTreeIsLeave(BinarySearchNode *node);
```

- 根据当前节点是否的左右孩子结点是否存在来判断。


### 查询节点的前驱节点

```c
/* 查询二叉树的前驱结点
 * @param *node 要插入元素的树
 * @return 返回查找到的前驱结点 
 */
static BinarySearchNode *binarySearchTreeGetPrecursor(BinarySearchNode *node);
```

前驱节点就是按照二叉树的中序遍历顺序排列，当前节点的前一个节点。

- 如果当前节点具有左子树，那么当前节点的前驱节点是当前节点的左节点的右节点的右节点...
  - 判断这个节点是否具有左节点。
  - 若具有左节点，使`travelNode`遍历到当前节点的左节点。
  - 使`travelNode`一直向`travelNode->right`遍历，直到`travelNode->right`为空。
  - `travelNode`就是查找到的前驱节点。
- 如果当前节点没有左子树，那么当前节点的前驱节点位于当前节点的上层，需要遍历当前节点的所有父节点，一直到当前节点是父节点的右节点。
  - 使`travelNode`赋值为需要查找的结点。
  - 当满足`travelNode->parent != NULL && travelNode == travelNode->parent->left`时，将`travelNode`赋值为`travelNode->parent`。
  - 重复上一步直到条件不满足。
  - `travelNode->parent`就是查找到的前驱节点。

### 查询节点的后继节点

```c
/* 查询二叉树的后继及诶单
 * @param *node 要插入元素的树
 * @return 返回查找到的前驱结点 
 */
static BinarySearchNode *binarySearchTreeGetSuccessor(BinarySearchNode *node);
```

后继节点就是按照二叉树的中序遍历顺序排列，当前节点的下一个节点。

- 如果当前节点具有右子树，那么当前节点的后继节点是当前节点的右节点的左节点的左节点...

  - 判断这个节点是否具有右节点。

  - 若具有右节点，使`travelNode`遍历到当前节点的右节点。

  - 使`travelNode`一直向`travelNode->left`遍历，直到`travelNode->left`为空。

  - `travelNode`就是查找到的前驱节点。

- 如果当前节点没有左子树，那么当前节点的后继节点位于当前节点的上层，需要遍历当前节点的所有父节点，一直到当前节点是父节点的左节点。
  - 使`travelNode`赋值为需要查找的结点。
  - 当满足`travelNode->parent != NULL && travelNode == travelNode->parent->right`时，将`travelNode`赋值为`travelNode->parent`。
  - 重复上一步直到条件不满足。
  - `travelNode->parent`就是查找到的前驱节点。

### 遍历二叉排序树

#### 中序遍历

```c
/* 中序遍历
 * @param *pTree 需要遍历的树
 * @param *travelNode 当前遍历的节点
 * @return 返回遍历结果
 */
static int binarySearchTreeInnerInOrder(BinarySearchTree *pTree, BinarySearchNode *travelNode);
```

- 调用当前函数递归遍历当前节点`travelNode`的左子树。
- 使用打印器函数打印当前结点的数据。
- 调用当前函数递归遍历当前节点`travelNode`的右子树。

#### 前序遍历

```c
/* 前序遍历
 * @param *pTree 需要遍历的树
 * @param *travelNode 当前遍历的节点
 * @return 返回遍历结果
 */
static int binarySearchTreeInnerPreOrder(BinarySearchTree *pTree,BinarySearchNode *travelNode);
```

- 使用打印器函数打印当前结点的数据。
- 调用当前函数递归遍历当前节点`travelNode`的左子树。
- 调用当前函数递归遍历当前节点`travelNode`的右子树。

#### 后序遍历

```c
/* 后序遍历
 * @param *pTree 需要遍历的树
 * @param *travelNode 当前遍历的节点
 * @return 返回遍历结果
 */
static int binarySearchTreeInnerPreOrder(BinarySearchTree *pTree,BinarySearchNode *travelNode);
```

- 调用当前函数递归遍历当前节点`travelNode`的左子树。
- 调用当前函数递归遍历当前节点`travelNode`的右子树。

- 使用打印器函数打印当前结点的数据。

#### 层序遍历

```c
/* 层次遍历
 * @param *pTree 需要遍历的树
 * @return 返回遍历结果
 */
int binarySearchTreeLevelOrder(BinarySearchTree *pTree);
```

- 初始化一个队列。
- 将树的根结点入队。
- 从队列中拿出一个节点，并将该节点的左右孩子结点入队。
- 重复上述两步直到队列为空。
- 销毁队列。

### 根据相应的值获取这个值所对应的节点

```c
/* 根据相应的值获取这个值所对应的节点
 * @param *pTree 需要遍历的树
 * @param data 需要查询的数据
 * @return 返回查询到的节点
 */
static BinarySearchNode *baseAppointValGetBSTreeNode(BinarySearchTree *pTree, ELEMENTTYPE data);
```

依次比较节点，直到当前节点为空：

- 若需要查找的值`小于`当前节点的数据，则向左继续查找；
- 若需要查找的值`大于`当前节点的数据，则向右继续查找；
- 若需要查找的值`等于`当前节点的数据，则返回当前节点；

### 删除树的节点

```c
/* 删除树的节点
 * @param *pTree 需要遍历的树
 * @param delNode 需要删除的节点
 * @return 返回查询到的节点
 */
static int binarySearchDeleteNode(BinarySearchTree *pTree, BinarySearchNode *delNode);
```

- 若删除的是叶子节点，直接删即可；
- 若删除的节点有一个孩子结点，检验当前节点是父节点的左节点还是右节点还是为`NULL`:
  - 若为空，切换当前二叉树的根结点为当前节点的孩子结点。
  - 若当前节点是其父节点的`左孩子`，那么将当前节点的父节点的`左孩子`设置为当前节点的孩子结点。
  - 若当前节点是其父节点的`右孩子`，那么将当前节点的父节点的`右孩子`设置为当前节点的孩子结点。
- 若需要删除的节点是度为2的节点，掺杂或当前节点的前驱节点，将前驱节点的数据域复制到当前节点的数据域，之后删除当前节点的前驱结点即可。

### 查询树的高度

```c
/* 删除树的节点
 * @param *pTree 需要遍历的树
 * @param *pHeight 传出参数，需要传出的树的高度
 * @return 返回查询到的节点
 */
int binarySearchTreeGetHeight(BinarySearchTree *pTree, int *pHeignt);
```

使用层序遍历遍历二叉树，设置`levelSize`初始值为`1`：

- 当有节点出队时，`levelSize`减一；
- 当`levelSize`为0时，树的高度信息加一；
- 重新设置`levelSize`的值为当前队列中的元素个数。

重复上述步骤直到队列为空。

























