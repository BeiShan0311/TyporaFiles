## 一、数据结构

```c
typedef struct BinarySearchNode
{
    ELEMENTTYPE data;
    struct BinarySearchNode *left;
    struct BinarySearchNode *right;
    struct BinarySearchNode *parent;
} BinarySearchNode;

typedef struct BinarySearchTree
{
    // 根节点
    BinarySearchNode *root;
    // 树的元素个数
    int size;
    // 树的高度
    int height;
    // 自定义比较器
    int (*comparaFunc)(ELEMENTTYPE arg1, ELEMENTTYPE arg2);
    // 自定义打印器
    int (*printFunc)(ELEMENTTYPE arg);
} BinarySearchTree;
```

## 二、二叉排序树函数实现

### 初始化

```c
/* 二叉排序树初始化
 * @param **pTree 要初始化的树
 * @param *compareFunc 需要传入的比较器
 * @param *printFunc 需要传入的打印器
 * @return 非零表示插入失败
 */
int binarySearchTreeInit(BinarySearchTree **pTree, int (*compareFunc)(ELEMENTTYPE, ELEMENTTYPE), int (*printFunc)(ELEMENTTYPE));
```

- 判空。
- 初始化一个二叉排序树。
- 设置二叉排序树的高度为`0`。
- 设置二叉排序树的元素个数为`0`。
- 将二叉排序树的根节点设置为`NULL`。
- 设置二叉排序树的比较器。
- 设置二叉排序树的打印器。

### 插入

```c
/* 二叉排序树初始化
 * @param *pTree 要插入元素的树
 * @param data 需要插入的数据
 * @return 非零表示插入失败
 */
int binarySearchTreeInsert(BinarySearchTree *pTree, ELEMENTTYPE data);
```

- 判空。
- 创建一个`travelNode`结点，使其等于`根结点`。
- 初始化一个`parentNode`结点，总是令其等于`travelNode`的`父母结点`。
- 初始化一个`newNode`结点，数据为传入的`data`，作为插入结点。
- 判断当前需要插入的是否为根结点，如果是，直接将`newNode`设置为根结点。
- 如果不是，用`travelNode`遍历二叉排序树直到找到当前节点应该插入的位置。
- 此时，`parentNode`为当前`travelNode`的父母结点。
- 比较器返回的结果确定要插入的是左子树还是右子树。
- 插入节点。

### 判断节点类型

```c
// 节点的度为2
static int binarySearchTreeHasTwoChildrens(BinarySearchNode *node);

// 节点的度为1
static int binarySearchTreeHasOneChild(BinarySearchNode *node);

// 叶子节点
static int binarySearchTreeIsLeave(BinarySearchNode *node);
```

- 根据当前节点是否的左右孩子结点是否存在来判断。


### 查询节点的前驱节点



### 查询节点的后继节点



### 遍历二叉排序树

