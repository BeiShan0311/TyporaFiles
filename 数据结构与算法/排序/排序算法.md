# 排序算法总结

## 一、冒泡排序

#### 算法思想:

每一次排序操作将未排序的数组元素中的最大值(最小值)移动到最末尾(前端)的位置。

即每一次排序确定最值的正确位置。

#### 实现思路：

1. 从数组的`0`号元素开始，向后遍历所有`未排序`的数组元素。
2. 若后一个元素比前一个元素大，交换两个数组元素直到遍历到最后一个`未排序`的数组元素的前一个。
3. 此时认为最后一个未排序的元素是当前`未排序`的数组元素中的最大值，认为最后一个`未排序`的数组元素已经排好序了。
4. 重复上述步骤直到未排序的数组元素只剩一个，此时认为这个元素也是拍好序的。

#### 示例代码：

```c
for (int sortedIdx = numSize; sortedIdx > 0; sortedIdx--)
{
    for (int begin = 1; begin < sortedIdx; begin++)
    {
        if (nums[begin - 1] > nums[begin])
        {
            // 交换两个数
            swapNum(&(nums[begin - 1]), &nums[begin]);
        }
    }
}
```

#### 两种冒泡排序的改进算法

- 标记数组是否排好序：

  当相邻的两个数组元素发生交换时，此时这两个数组元素是乱序的状态，因此认为整个数组是未排序的状态。

  因此，当某次遍历没有发生数组元素的交换时，整个数组就是排好序的状态。

  根据以上思想对冒泡排序进行改进，增加标记位，标记数组是否排好序。

```c
int sorted = 0;
for (int end = numSize; end > 0; end--)
{
    sorted = 1;
    for (int begin = 1; begin < end; begin++)
    {
        if (nums[begin - 1] > nums[begin])
        {
            // 交换两个数
            swapNum(&(nums[begin - 1]), &nums[begin]);
            sorted = 0;
        }
    }

    if (sorted == 1)
    {
        // 已经排好序了
        break;
    }
}
```

- 标已经排好序的数组元素位置。

  根据上一个改进代码的思想，当某次遍历在某个数组下标发生交换时，认为这个数组下标向前的数组数据都是未排序的状态。当遍历整个数组下标往后的所有元素时，若都没有发生数据的交换，则认为这个数组下标之后的所有元素都是排好序的状态。

  根据以上思路，可以记录下当前已经排好序的数组下标。

```c
int sortedIdx = numSize;
for (int end = sortedIdx; end > 0; end = sortedIdx)
{
    sortedIdx = 0;
    for (int begin = 1; begin < end; begin++)
    {
        if (nums[begin - 1] > nums[begin])
        {
            // 交换两个数
            swapNum(&(nums[begin - 1]), &nums[begin]);
            sortedIdx = begin;
        }
    }

    // 已排好序的索引为0 所有位置都已经排好序了
    if (sortedIdx == 0)
    {
        break;
    }
}
```

## 二、选择排序

在使用冒泡算法时，不仅重复遍历数组需要耗费资源，交换元素也要耗费一定的系统资源。

当数组元素为反序时，冒泡排序的排序就不是很理想。

为了解决冒泡排序重复交换元素所产生的系统资源的浪费，提出了选择排序算法：

#### 算法思想：

找到未排序的数组元素中最大的数组元素的下标，将其与未排序的数组元素下标最大的位置的元素交换。

这样每次排序只会产生一次元素交换，大大节省交换元素带来的资源耗费。

#### 实现思路：

1. 遍历未排序的数组元素，找到最大的数组元素下标。
2. 将其与下标最大的未排序的数组元素交换。
3. 重复上述步骤直到未排序的数组元素只剩一个。

#### 示例代码：

```c
// 找到数组最小值
int findNumMinVal(int *nums, int numSize, int *pos)
{
    if (nums == NULL)
    {
        return -1;
    }

    if (numSize <= 0)
    {
        return -2;
    }

    int min = nums[0];
    // 每次更改min值时都需要修改相应的pos值
    *pos = 0;

    for (int idx = 1; idx < numSize; idx++)
    {
        if (min > nums[idx])
        {
            min = nums[idx];
            *pos = idx;
        }
    }

    return min;
}

// 选择排序
int selectSort(int *nums, int numSize)
{
    if (nums == NULL)
    {
        return -1;
    }

    if (numSize <= 0)
    {
        return -2;
    }

    // 每循环一次
    // 最小值被放在最前面
    // 为了找到次小的数据
    // 数组初始位置(*nums)需要往后延一个位置
    // 相应的数组个数(numSize)会减一
    // 倒数第二个排好序，最后一个也就排好序了
    for (int idx = 0; idx < numSize - 1; idx++)
    {
        int pos = idx;
        // 循环idx次
        // 数组初始位置(*nums)需要往后延idx位置
        // 相应的数组个数(numSize)会减idx
        findNumMinVal(&(nums[idx]), numSize - idx, &pos);
        // 由于pos返回的是数组大小修改后的位置值, 因此需要加上循环次数idx
        // 才是原数组的正确下标
        swapNum(&(nums[idx]), &(nums[pos + idx]));
    }

    return 0;
}
```

## 三、插入排序

选择排序每次都会确定一个未排序数组元素中的最大值的确切位置，但是交换操作可能会将原本已经是排好序的数组元素打乱。

因此采用不交换元素的插入排序算法：

#### 算法思想：

从数组下标为`1`的位置处开始排序，认为当前下标之前的元素都是排好序的状态，将这个下标的数组元素插入到当前下标之前的数组元素之中，并保证还是排好序的状态。

#### 实现思路：

1. 认为下标为`0`的数组元素是排好序的状态。
2. 往后遍历一个数组元素。
3. 确定这个数组元素在这个数组元素及其之前的所有数组元素中的确切位置。
4. 重复`2,3`两步直到遍历完整个数组。

### 示例代码：

```c
for (int idx = 1; idx < numSize; idx++)
{
    // 记录要插入的数据
    int insertNum = nums[idx];

    int prevIdx = idx - 1;

    while (nums[prevIdx] > insertNum && prevIdx >= 0)
    {
        nums[prevIdx + 1] = nums[prevIdx];
        prevIdx--;
    }
    nums[prevIdx + 1] = insertNum;
}
```

## 四、快速排序

#### 算法思想：

上述的排序算法都是每次确定一个数组元素最值的最终位置，而快速排序的每次排序都会确定第一个数组元素在排好序之后应该在的位置。

#### 实现思路：

1. 设置变量`aix`的值为要确定位置的数组元素的下标数`+1`。
2. 往后遍历数组，若比要排序的数组元素值小，且遍历到的数组元素下标比`aix`的值大，则交换下标为`aix`的数组元素与遍历到的数组元素，并将`aix`的值`+1`。
3. `aix`的值就是要排序的数组元素排好序后应该在的位置。
4. 将要排序的数组元素与下标为`aix`的数组元素交换
5. 重复上述步骤，排序下标`aix`之前的数组，直到`aix`前的数组元素只剩一个。
6. 重复上述步骤，排序下标`aix`之后的数组，直到`aix`后的数组元素只剩一个。

#### 示例代码：

```c
int quickSort(int *nums, int numSize, int beginPos)
{
    int aix = beginPos + 1;
    // 从aix处开始查找 nums[beginPos]应该放置的位置
    for (int idx = aix; idx < numSize; idx++)
    {
        if (nums[idx] < nums[beginPos])
        {
            if (idx > aix)
            {
                swapNum(&nums[idx], &nums[aix]);
            }
            aix++;
        }
    }
    // aix下标为第一个比nums[beginPos]大的数据位置

    // 将nums[beginPos]放在对的位置上
    swapNum(&nums[beginPos], &nums[aix - 1]);

    // 若aix枢轴后的内容为1个或者0个 认为排序完成
    if (aix - 1 > 1)
    {
        // 将aix枢轴前的内容排序
        quickSort(nums, aix - 1, 0);
    }

    // 若aix枢轴后的内容为1个或者0个 认为排序完成
    if (numSize - aix > 1)
    {
        // 将aix枢轴后的内容排序
        quickSort(nums + aix, numSize - aix, 0);
    }

    return 0;
}
```