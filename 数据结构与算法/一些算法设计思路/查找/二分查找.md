# 二分查找

## 一、二分查找要求

1. 查找的元素必须有序。
2. 元素具有可比较性。

## 二、二分查找算法思想

二分查找使用了类似分治的思想，二分查找每次都可以将待检索区间缩小一半，实现`O(logN)`的算法时间复杂度。二分查找针对的是一个有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。

## 三、二分查找算法

1. 首先设定二分查找的区间范围`begin`和`end`。
2. 检查元素位置为`(begin + end) / 2`的元素。
   - 若元素位置为`(begin + end) / 2`的元素与待检索元素相等，返回下标`(begin + end) / 2`。
   - 若元素位置为`(begin + end) / 2`的元素大于待检索元素，设置`end`值为`(begin + end) / 2 + 1`。
   - 若元素位置为`(begin + end) / 2`的元素小于待检索元素，设置`begin`值为`(begin + end) / 2 - 1`。
3. 重复第二步直到检索到目标元素，或者`begin`值大于`end`值。

## 四、二分查找源码

```c
int binarySearch(int *nums, int numSize, int target)
{
    if (nums == NULL)
    {
        return -1;
    }

    if (numSize <= 0)
    {
        return -1;
    }

    int begin = 0;
    int end = numSize - 1;

    while (begin <= end)
    {
        int mid = (begin + end) >> 1;
        if (nums[mid] == target)
        {
            return mid;
        }
        else if (nums[mid] < target)
        {
            begin = mid + 1;
        }
        else if (nums[mid] > target)
        {
            end = mid - 1;
        }
    }

    return -1;
}
```

## 五、基于二分查找的插入

基于二分查找查找最后一个`<=`待查找元素的值的位置，用以优化插入排序。

```c
// 寻找插入位置
static int searchInsert(int *nums, int numsSize, int target)
{
    if (nums == NULL)
    {
        return -1;
    }

    if (numsSize <= 0)
    {
        return -1;
    }

    int begin = 0;
    int end = numsSize - 1;

    int ret = -1;

    while (begin < end)
    {
        int mid = (begin + end) >> 1;
        if (nums[mid] <= target)
        {
            begin = mid + 1;
        }
        else
        {
            end = mid - 1;
        }
    }

    if (nums[begin] <= target)
    {
        ret = begin + 1;
    }
    else
    {
        ret = begin;
    }

    return ret;
}
```

