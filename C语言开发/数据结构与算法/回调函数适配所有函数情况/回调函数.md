## 0. 函数指针

**首先，计算机只会处理`0`和`1`的数据。**

###### 计算机怎么认识一个函数的？

所有的C语言程序在编译时都会进行`预编译`->`编译`->`汇编`->`链接`这四个阶段，这一部分的内容在[MakeFile基础](../../Linux开发/makefile/makefile基础.md)中详细介绍过，这里不再赘述。

所有的C语言文件最终都会被编译器编译为可执行文件，也就是一个全是0和一二进制文件，到这里计算机才能认识并处理这个文件。

暂且不管计算机会怎么处理这些内容。

那么，既然计算机能识别的只有`0`和`1`，函数在这份文件中有什么特殊的地方呢。

首先，函数在编译时，编译器会生成相应的二进制代码，告诉计算机这是一个函数。

在这之后，编译器会对把包含这份函数数据段放到一块叫做`代码段`的区域，并给这个函数分配一个`地址`。

显然，这个区域是在内存条上的，因为只有内存条上的内容才能被计算机处理。

这个内存区域与之前的`堆区`、`栈区`等内存区域相比，是另外的内存区域，对程序员不可见。只有在程序执行时才会进行分配。

###### 如何访问函数？

现在，注意到C语言中的指针变量，既然函数代码会被存放在内存区，那么C语言就可以使用指针来访问这个内存区域，实际上C语言也是这么做的。

因此，可以将函数看做一个特殊的`结构体`，只不过这个结构体存放在`代码段`并且这个结构体内部存放的是一段代码。

调用这个特殊的`结构体`就是在调用并执行这段函数。

那么，存放在内存空间的数据那么多，我怎么知道这一块是函数还是数据呢？

并且C语言中还有相同函数名不同函数参数的同名函数，又怎么区别它们呢。

C语言的做法是，规定调用函数的指针格式为`[函数返回值类型] (*[函数指针变量名])([参数1类型], [参数2类型], ...)`。

在保证函数指针变量的参数列表与要调用的函数的变量列表相同的情况下，将要调用的函数地址赋给变量`[函数指针变量名]`，即可通过这个函数指针调用地址指向的函数。

###### 如何使用函数指针？

函数指针的使用格式有很多，例如`回调函数`，`动态函数`，`函数数组`等，在使用时，将需要的参数列表放在函数指针的后面即可。相同参数列表的函数指针可以赋给同一个函数指针变量。

以下是一个例子

```C
#include <stdio.h>

int add(int a, int b) {
    return a + b;
}

int main() {
    // 声明一个函数指针
    int (*functionPtr)(int, int);

    // 将函数的地址赋值给函数指针
    functionPtr = &add;  // 或者可以简写为 functionPtr = add;

    // 通过函数指针调用函数
    int result = functionPtr(3, 4);

    // 打印结果
    printf("Result: %d\n", result);

    return 0;
}

```

------

## 1. 使用回调函数适配所有数据结构

###### 认识void

首先需要了解C语言中一个特殊的类型`void`，可以将任意类型的数据赋值给一个`void`类型的数据。

当然，在数据结构中任何大小大于`2字节`的数据都需要使用指针传递。因此实际开发中需要用到的是`void *`指针类型，同样的，也可以将任意类型的指针数据赋值给它。

使用`void *`类型传递指针数据解决了程序传递所有类型数据的问题。

###### 为什么需要回调函数

当一些对基本数据类型的数据的操作在复合数据类型上不易实现时，需要用到回调函数。

例如，比较两个参数的大小，在整形等基本数据类型中非常容易实现，只需要两个数字相减就可以了。但是对于复合数据类型，一般比较的规则比较复杂，如果全部由程序员在程序内部实现的话，当用户改动这个复合数据类型的比较规则时，就需要找程序员进行维护，这非常不方便。

因此，引入了回调函数，直接传递一个用户需要实现的函数效果的函数指针，通过这个函数指针来实现`查找`、`排序`、`比较`等操作。

加入回调函数，提高了程序的可移植性。













