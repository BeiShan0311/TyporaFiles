# 线程——CPU调度的基本单位

## 线程的定义

- 线程依托进程而存在。
- 线程的创建也是基于进程创建的。
- 当一个进程没有线程时，该进程就会退化为线程。

## 线程的优势

- 线程共享进程的全部资源。
- 线程之间除了一组独立的栈空间以及线程号不同以外，所有的资源都是共享的。
- 线程和进程的函数在底层上都是相同的。
- 做同样的操作线程花费的资源较少。

## 线程的相关函数

##### `pthread_t pthread_self(void)` - 返回当前线程的线程号

```c
#include <stdio.h> 
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    pthread_t tid = pthread_self();

    pid_t pid = getpid();

    printf("thread id : %ld\n", tid);
    printf("process id : %d\n", pid);

    return 0;
}
```

##### `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);`创建线程。

- `pthread_t *thread` 传入参数，用于返回创建的线程的线程号。
- `const pthread_attr_t *attr` 指定线程属性，一般置为NULL，表示默认属性。】
- `void *(*start_routine) (void *)` 新创建线程从此函数开始运行。
- `void *arg` 执行函数的参数列表。

```c
#include <stdio.h>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

void *thread_func(void *)
{
    printf("new thread:%ld\n", pthread_self());

    while (1)
    {
    }
}

int main()
{
    pthread_t tid;

    int ret = pthread_create(&tid, NULL, thread_func, NULL);
    if (ret != 0)
    {
        printf("pthread_create error\n");
        exit(-1);
    }

    printf("main thread:%ld\n", pthread_self());

    while (1)
    {
    }

    sleep(1);
    return 0;
}
```

##### `int pthread_join(pthread_t thread, void **retval);` - 线程资源回收。类似进程回收函数`wait`

- 此函数是一个阻塞函数。
- `pthread_t thread` 需要回收资源的线程号。
- `void **retval` 传出参数。传递线程结束信息，当线程正常结束时，传出参数为`PTHREAD_CANCELED`。

```c
#include <stdio.h>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

void *thread_func(void *)
{
    printf("new thread:%ld\n", pthread_self());
    sleep(3);
    // 线程退出
    // 1.static 修饰的变量在程序结束时才会释放
    // 2.malloc 
    // 局部变量退出
    // int retStatus = -1;
    static int retStatus = -1;
    pthread_exit(&retStatus);
}

int main()
{
    pthread_t tid;

    int ret = pthread_create(&tid, NULL, thread_func, NULL);
    if (ret != 0)
    {
        printf("pthread_create error\n");
        exit(-1);
    }

    // tid 就是创建进程的id号
    printf("tid:%ld\n", tid);
    printf("main thread:%ld\n", pthread_self());

    // 阻塞等待回收子进程的资源
    int *retval = NULL;
    pthread_join(tid, (void **)&retval);
    printf("retval:%d\n", *retval);
    sleep(1);
    return 0;
}
```

##### `void pthread_exit(void *retval);` - 线程退出。

- 传出参数，传出线程退出的状态。

##### `int pthread_cancel(pthread_t thread);` - 杀死线程。

- `pthread_t thread` 线程号。

```c
#include <stdio.h>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

void *thread_func(void *)
{
    printf("new thread:%ld\n", pthread_self());

    while (1)
    {
        printf("i am thread...\n");
        sleep(1);
    }

    // 线程退出
    // 1.static 修饰的变量在程序结束时才会释放
    // 2.malloc
    // 局部变量退出
    // int retStatus = -1;
    static int retStatus = -1;
    pthread_exit(&retStatus);
}

int main()
{
    pthread_t tid;

    int ret = pthread_create(&tid, NULL, thread_func, NULL);
    if (ret != 0)
    {
        printf("pthread_create error\n");
        exit(-1);
    }

    sleep(5);
    // 类似进程的kill函数
    pthread_cancel(tid);

    // tid 就是创建进程的id号
    printf("tid:%ld\n", tid);
    printf("main thread:%ld\n", pthread_self());

    // 阻塞等待回收子进程的资源
    int *retval = NULL;
    pthread_join(tid, (void **)&retval);
    printf("retval:%d\n", *retval);

    sleep(1);
    return 0;
}
```

##### `int pthread_detach(pthread_t thread);` - 线程分离函数

- 分离的线程还是依赖当前线程。只是将回收动作交给系统完成。
- `pthread_t thread` 要分离的进程的进程号。

- 对于处于`detach`状态的线程，不能使用`pthread_join`函数调用它。

```c
#include <stdio.h>
#include <pthread.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <error.h>
#include <errno.h>

void *thread_func(void *)
{
    pthread_detach(pthread_self());
    printf("new thread:%ld\n", pthread_self());

    while (1)
    {
        printf("i am thread...\n");
        sleep(1);
    }

    // 线程退出
    // 1.static 修饰的变量在程序结束时才会释放
    // 2.malloc
    // 局部变量退出
    // int retStatus = -1;
    static int retStatus = -1;
    pthread_exit(&retStatus);
}

int main()
{
    pthread_t tid;

    int ret = pthread_create(&tid, NULL, thread_func, NULL);
    if (ret != 0)
    {
        printf("pthread_create error\n");
        exit(-1);
    }
    // 在主线程中执行延时，让子线程先执行分离函数
    sleep(1);
    // 阻塞等待回收子进程的资源
    int *retval = NULL;
    ret = pthread_join(tid, (void **)&retval);
    if (ret == EINVAL)
    {
        printf("detached...\n");
    }

    int cnt = 5;

    while (cnt--)
    {
        printf("main thread\n");
        sleep(1);
    }

    if (retval)
    {

        printf("retval:%d\n", *retval);
    }

    return 0;
}
```





