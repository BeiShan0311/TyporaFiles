# 线程同步机制

## 线程的资源

- 线程除了id号独立，其他资源都是共享的。

- 线程不共享各自的栈空间。

## 线程同步机制——互斥锁

加锁操作是一件非常浪费CPU时间的事情。

#### 互斥锁`mutex`。

互斥锁分为：互斥锁，读写锁，自旋锁等。根据使用场景以及资源消耗的不同，采用不同的锁。

每当一个线程需要访问公共区资源时，给这个公共区资源上锁，其他所有的线程都不能访问这块公共区资源。

#### 互斥锁的相应函数

**初始化锁**

```c
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
```

- `pthread_mutex_t *restrict mutex` 需要初始化的互斥锁。
- `const pthread_mutexattr_t *restrict attr` 通常置为空。

**销毁锁**

```c
 int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

- `pthread_mutex_t *mutex` 需要销毁的互斥锁。

**上锁**

```c
int pthread_mutex_lock(pthread_mutex_t *mutex);
```

- `pthread_mutex_t *mutex` 需要上锁的互斥锁。

**解锁**

```c
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

- `pthread_mutex_t *mutex` 需要解锁的互斥锁。

#### 实例代码

```c
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

// 资源
int g_data = 10;

// 互斥锁
pthread_mutex_t g_lock;

void printer(const char *str)
{
    pthread_mutex_lock(&g_lock);
    while (*str)
    {
        putchar(*str);
        str++;
    }
    pthread_mutex_unlock(&g_lock);
}

void *thread_func_1(void *arg)
{
    char *str = "hello";

    printer(str);
}

void *thread_func_2(void *arg)
{
    char *str = "world";
    printer(str);
    printf("\n");

    /* 行缓存 */
}

int main()
{
    // 初始化锁
    pthread_mutex_init(&g_lock, NULL);

    pthread_t tid1, tid2;
    int ret = pthread_create(&tid1, NULL, thread_func_1, NULL);
    if (ret == -1)
    {
        printf("pthread_1_create error\n");
        exit(-1);
    }

    ret = pthread_create(&tid2, NULL, thread_func_2, NULL);
    if (ret == -1)
    {
        printf("pthread_2_create error\n");
        exit(-1);
    }

    while (1)
    {
        sleep(1);
    }

    pthread_mutex_destroy(&g_lock);

    return 0;
}
```

## 线程同步机制——条件变量

#### 条件变量condition

条件变量本身是用来等待的，它本身是没有锁的。

条件变量的提示机制有两种：

- `int pthread_cond_broadcast(pthread_cond_t *cond);` 广播方式，提示所有需要使用共享资源的线程来使用资源。
- `int pthread_cond_signal(pthread_cond_t *cond);` 提示一个或多个线程来使用资源。

一般会使用`pthread_cond_signal` 方式来提示线程使用临界区资源。

#### 条件变量的相应函数

**初始化锁条件变量**

```c
int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);
```

- `pthread_cond_t *restrict cond` 需要注册的条件变量。
- `const pthread_condattr_t *restrict attr` 通常置为空。

**销毁条件变量**

```c
int pthread_cond_destroy(pthread_cond_t *cond);
```

- `pthread_cond_t *cond` 需要销毁的条件变量。

**条件变量阻塞函数**

```c
int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);
```

- `pthread_cond_t *restrict cond` 需要等待的变量。
- `pthread_mutex_t *restrict mutex` 等待条件变量满足前需要使其阻塞的线程。
- **当前函数必须在互斥锁里面执行。**

**条件变量**

```c
int pthread_cond_signal(pthread_cond_t *cond);
```

- `pthread_cond_t *cond` 提示执行的条件变量。

#### 示例代码

```c
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>

// 互斥锁 资源
pthread_mutex_t g_mutex;

// 条件变量
pthread_cond_t g_freePlates;
pthread_cond_t g_enoughPie;

// 链表作为容器
typedef struct Node
{
    int data;
    struct Node *next;
} Node;

// 链表头结点
Node *head = NULL;

int g_count = 0;

// 盘子数量
const int maxPlate = 10;

// 生产者进程
void *thread_productor(void *arg)
{
    while (1)
    {
        pthread_mutex_lock(&g_mutex);
        // 当前生产的数量已经达到最大
        while (g_count == maxPlate)
        {
            pthread_cond_wait(&g_freePlates, &g_mutex);
        }

        // 程序到这说明有足够的盘子

        // 创建一个链表节点
        Node *newNode = (Node *)malloc(sizeof(Node));
        // 0-999 的序号
        newNode->data = rand() % 999 + 1;

        // 头插节点,生产一个
        newNode->next = head;
        head = newNode;
        printf("productor make %d\n", newNode->data);

        g_count++;

        pthread_mutex_unlock(&g_mutex);
        // 通知顾客
        pthread_cond_signal(&g_enoughPie);

        // 休息1s
        sleep(1);
    }
}

// 消费者进程1
void *thread_consumer(void *arg)
{
    while (1)
    {
        // 程序执行到这，说明有足够的资源
        pthread_mutex_lock(&g_mutex);

        while (g_count == 0)
        {
            pthread_cond_wait(&g_enoughPie, &g_mutex);
        }

        // 还有资源
        Node *newNode = head;
        head = head->next;
        printf("tid:%ld\tconsumer eat %d\n", pthread_self(), newNode->data);

        g_count--;

        // 释放内存
        if (newNode != NULL)
        {
            free(newNode);
            newNode = NULL;
        }

        pthread_mutex_unlock(&g_mutex);
        pthread_cond_signal(&g_freePlates);
        // 通知老板
    }
}

int main()
{
    // 初始化锁
    pthread_mutex_init(&g_mutex, NULL);

    // 初始化条件变量
    pthread_cond_init(&g_freePlates, NULL);
    pthread_cond_init(&g_enoughPie, NULL);

    pthread_t tid1, tid2, tid3;
    int ret = pthread_create(&tid1, NULL, thread_productor, NULL);
    if (ret == -1)
    {
        printf("pthread_1_create error\n");
        exit(-1);
    }

    ret = pthread_create(&tid2, NULL, thread_consumer, NULL);
    if (ret == -1)
    {
        printf("pthread_2_create error\n");
        exit(-1);
    }

    ret = pthread_create(&tid3, NULL, thread_consumer, NULL);
    if (ret == -1)
    {
        printf("pthread_3_create error\n");
        exit(-1);
    }

    while (1)
    {
        sleep(1);
    }
    
    pthread_cond_destroy(g_freePlates);
    pthread_cond_destroy(g_enoughPie);

    // 销毁锁
    pthread_mutex_destroy(&g_mutex);

    return 0;
}
```

## 线程同步机制——信号量

#### 信号量semaphore相关函数

**信号量初始化**

```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

- `sem_t *sem` 需要注册的信号量。
- `int pshared` 0 - 线程信号量，1 - 进程信号量。
- `unsigned int value` 信号量的个数。

**信号量销毁**

```c
int sem_destroy(sem_t *sem);
```

- `sem_t *sem` 要销毁的信号量。

**信号量P操作**

```c
int sem_wait(sem_t *sem);
```

- `sem_t *sem` 要阻塞的信号量。

**信号量V操作**

```c
int sem_post(sem_t *sem);
```

- `sem_t *sem` 要唤醒的信号量。

#### 实例代码

```c
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <semaphore.h>

// 资源
int g_data = 10;

// 信号量
sem_t g_sem;

void printer(const char *str)
{
    sem_wait(&g_sem);
    while (*str)
    {
        putchar(*str);
        str++;
    }
    sem_post(&g_sem);
}

void *thread_func_1(void *arg)
{
    char *str = "hello";

    printer(str);
}

void *thread_func_2(void *arg)
{
    char *str = "world";
    printer(str);
    printf("\n");

    /* 行缓存 */
}

int main()
{
    // 初始化信号量
    sem_init(&g_sem, 0, 1);

    pthread_t tid1, tid2;
    int ret = pthread_create(&tid1, NULL, thread_func_1, NULL);
    if (ret == -1)
    {
        printf("pthread_1_create error\n");
        exit(-1);
    }

    ret = pthread_create(&tid2, NULL, thread_func_2, NULL);
    if (ret == -1)
    {
        printf("pthread_2_create error\n");
        exit(-1);
    }

    while (1)
    {
        sleep(1);
    }

    sem_destroy(&g_sem);

    return 0;
}
```







































