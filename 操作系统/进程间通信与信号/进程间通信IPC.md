# 进程间通信方式interpor-process communication

1. 为什么要有进程间通信？

   - 进程的内存空间是独立的，只能通过一些手段才能通信，所以需要有通信机制，即IPC。

2. 进程通信的目的

   数据传输

   通知事件

   资源共享

   进程控制

3. 进程通信的方式：

   - 无名管道：

     管道之间的通信只能在父子或祖先和子进程间通信。

     无名管道的特点：

     - 半双工通信，数据在同一时间只能在一个方向上流动。
     - 数据只能从管道的一端写入，另一端读出。
     - 写入管道的数据遵循先进先出的原则。
     - 管道通信传输的数据是无格式的，要求管道的读出方式与写入方式需要事先约定好数据的格式。
     - 管道不是普通的文件，不属于文件系统，只存在于内存中。
     - 管道在内存中对应一个缓冲区，不同系统的大小不同。
     - 管道的读取数据操作是一次性的，只要被读出，数据就会消失。
     - 管道之间的通信只能在父子或祖先和子进程间通信。

     **管道函数：**

     1. pipe()

        创建一个无名管道。

        pipefd是两个文件描述符

        fd[0] 用于读取管道

        fd[1] 用于写入管道

     2. read是阻塞函数，如果没有数据，会一直阻塞

     3. 阻塞与非阻塞

        read读常规文件时，是一个非阻塞函数，一段时间后必定会返回。

        read读管道文件时，是一个阻塞函数。

     4. `fcntl()`函数

        用于设置文件描述符对应的属性。

   - 命名管道`FIFO`

     创建命名管道命令：`mkfifo [管道文件名称]`

     创建命名管道函数：`mkfifo()`

     命名管道可以在不具备亲属关系的进程之间进行通信。

   - 共享存储映射`mmap`

     最快的进程间通信方式

     **注意事项：**
     
     1. 创建映射区时，隐藏着一个文件读取操作。
     2. 当参数为`MAP_SHARED`时，要求隐身文件的权限范围需要小于文件的打开权限。当参数是`MAP_PRIVATE`时，权限无所谓。
     3. 映射区的释放与文件的关闭无关，当映射产生之后文件即可关闭。
     4. 当映射文件大小为0时，不能创建映射区。
     5. `munmap`函数的传入地址一定是`mmap` 的返回地址，因此返回的地址不能被改变。
     6. 文件的偏移量参数应该为4k的整数倍。
     7. `mmap`创建映射区的出错率较高。

4. 关于read函数的补充：

   由内核告知read函数可以读取数据。

   `read()`是会阻塞的函数。

   当没有数据时，`read`函数就会阻塞，当有新的数据可以读取时，由内核通知`read`函数。

   可以将`read`函数看做一个条件执行的函数，而内核的提醒就是条件满足。

   而这个条件就是`kill`信号。

5. 信号`kill`

   信号的基本要求：

   - 简单。
   - 不能携带大量的信息。
   - 需要满足某个条件才能发送。

   一些简答的信号：

   1. **SIGHUP (1)**: Hangup。通常由终端关闭或控制进程终止引起。当shell终止时，它会发送给其所有子进程。
   2. **SIGINT (2)**: Interrupt。通常由用户在终端上按下Ctrl+C产生。它是终止一个进程的标准方式。
   3. **SIGQUIT (3)**: Quit。通常由用户在终端上按下Ctrl+\产生。这会引起进程终止，并在退出时生成一个core转储。
   4. **SIGKILL (9)**: Kill。这是一个无法捕获或忽略的信号，可以立即终止进程。它是一种“最后手段”，用于确保进程被终止。
   5. **SIGTERM (15)**: Terminate。通常是要求一个进程优雅地终止，让它有机会清理资源并退出。
   6. **SIGUSR1 (30), SIGUSR2 (31)**: User-defined signal。这两个信号可由用户自定义使用，通常用于向进程发送自定义消息或触发特定动作。
   7. **SIGSTOP (19)**: Stop。停止一个进程的执行，但不会终止它。可以通过发送SIGCONT信号来恢复进程的执行。
   8. **SIGSEGV (11)** 当一个进程尝试访问其没有权限访问的内存区域（如访问空指针或者访问超出分配的内存范围）时触发。这通常表示程序中存在潜在的内存错误。
   9. **SIGFEP (8)** 当执行浮点运算时发生错误时触发，如除零操作或非法的数学运算。
   10. **SIGPIPE (13)**  当尝试向一个没有读取端的管道（或者Socket）写入数据时触发。
   11. **SIGCHLD (17)** 当子进程终止或停止时，父进程会收到这个信号。



































